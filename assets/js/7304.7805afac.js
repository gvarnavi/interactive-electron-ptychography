"use strict";(self.webpackChunkinteractive_ptycho=self.webpackChunkinteractive_ptycho||[]).push([[7304],{85162:(e,t,n)=>{n.r(t),n.d(t,{default:()=>a});n(67294);var r=n(90512);const i={tabItem:"tabItem_Ymn6"};var o=n(85893);function a(e){let{children:t,hidden:n,className:a}=e;return(0,o.jsx)("div",{role:"tabpanel",className:(0,r.default)(i.tabItem,a),hidden:n,children:t})}},74866:(e,t,n)=>{n.r(t),n.d(t,{default:()=>y});var r=n(67294),i=n(90512),o=n(12466),a=n(16550),l=n(20469),s=n(91980),c=n(67392),u=n(50012);function _(e){return r.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,r.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function f(e){const{values:t,children:n}=e;return(0,r.useMemo)((()=>{const e=t??function(e){return _(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:i}}=e;return{value:t,label:n,attributes:r,default:i}}))}(n);return function(e){const t=(0,c.duplicates)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:n}=e;const i=(0,a.useHistory)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s.useQueryStringValue)(o),(0,r.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(i.location.search);t.set(o,e),i.replace({...i.location,search:t.toString()})}),[o,i])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:i}=e,o=f(e),[a,s]=(0,r.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[c,_]=d({queryString:n,groupId:i}),[v,m]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[i,o]=(0,u.useStorageSlot)(n);return[i,(0,r.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:i}),h=(()=>{const e=c??v;return p({value:e,tabValues:o})?e:null})();(0,l.default)((()=>{h&&s(h)}),[h]);return{selectedValue:a,selectValue:(0,r.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);s(e),_(e),m(e)}),[_,m,o]),tabValues:o}}var m=n(72389);const h={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var b=n(85893);function g(e){let{className:t,block:n,selectedValue:r,selectValue:a,tabValues:l}=e;const s=[],{blockElementScrollPositionUntilNextRender:c}=(0,o.useScrollPositionBlocker)(),u=e=>{const t=e.currentTarget,n=s.indexOf(t),i=l[n].value;i!==r&&(c(t),a(i))},_=e=>{let t=null;switch(e.key){case"Enter":u(e);break;case"ArrowRight":{const n=s.indexOf(e.currentTarget)+1;t=s[n]??s[0];break}case"ArrowLeft":{const n=s.indexOf(e.currentTarget)-1;t=s[n]??s[s.length-1];break}}t?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.default)("tabs",{"tabs--block":n},t),children:l.map((e=>{let{value:t,label:n,attributes:o}=e;return(0,b.jsx)("li",{role:"tab",tabIndex:r===t?0:-1,"aria-selected":r===t,ref:e=>s.push(e),onKeyDown:_,onClick:u,...o,className:(0,i.default)("tabs__item",h.tabItem,o?.className,{"tabs__item--active":r===t}),children:n??t},t)}))})}function x(e){let{lazy:t,children:n,selectedValue:i}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===i));return e?(0,r.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:o.map(((e,t)=>(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==i})))})}function w(e){const t=v(e);return(0,b.jsxs)("div",{className:(0,i.default)("tabs-container",h.tabList),children:[(0,b.jsx)(g,{...e,...t}),(0,b.jsx)(x,{...e,...t})]})}function y(e){const t=(0,m.default)();return(0,b.jsx)(w,{...e,children:_(e.children)},String(t))}},4131:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),h=new e([a,l]),b=t.cos(m),g=t.sin(m);h.data=t.stack([b,g],-1);let x=u.multiply(h);return x.data=t.ifft(x.data),x}}function v(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function m(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function h(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function b(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function g(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(l,a)]}_evaluate_aberrations(e,t){let n=this._defocus/this._wavelength*Math.PI,i=e.multiply(e).multiply(n),a=r.cos(i),l=r.sin(i),s=new o(i.shape);return s.data=r.stack([a,l],-1),s}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i);this._fourier_array=a;let l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this}}}function x(e){return e`https://observablehq.com/@mootari/notebook-data`}function w(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],v),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],m),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",h),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],b),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],g),n.variable(t()).define(["md"],x),n}function y(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function j(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function k(e){return e.range([50,1e3],{value:200,step:25,label:"Animation speed [ms]"})}function P(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function z(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function A(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function q(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function D(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function R(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function M(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function I(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function C(e){return e.form({projection_name:e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"projection"}),projection_gamma:e.range([0,1],{value:.875,step:.001,label:"relaxation \u03b3"})})}function N(e,t,n){return e.form({projection_a:e.range([-1,1],{value:`${"Generalized"==t.projection_name?0:n[t.projection_name].a}`,step:.001,label:"parameter a"}),projection_b:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].b}`,step:.001,label:"parameter b"}),projection_c:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].c}`,step:.001,label:"parameter c"})})}function $(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function S(e){return e.checkbox(["iterate","reset","individual traces"],{value:[]})}function G(e,t,n,r){let i=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),o=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length)))),a=n.includes("individual traces")?t.map((e=>e[0])):[],l=n.includes("individual traces")?t.map((e=>e[1])):[],s=n.includes("individual traces")?t.map((e=>e[2])):[];return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...i],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(a,{stroke:"red",strokeDasharray:"4 4"}),r.line(l,{stroke:"blue",strokeDasharray:"4 4"}),r.line(s,{stroke:"green",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function T(e){return e.html`<hr class="hideable-md">`}function V(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e.projection_gamma,b:e.projection_gamma,c:2},RAAR:{a:1-2*e.projection_gamma,b:e.projection_gamma,c:2}}}function E(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function O(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function L(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function W(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function B(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function H(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function F(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[[c,u],[_,f],[o*l+n*c+r*_,o*s+n*u+r*f]]}}}function U(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function Y(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function J(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[h,b]]=u([[e,t],[n,r],[i,f]]),[[g,x],[w,y],[j,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*h+c*i,l*b+c*f]]);return[[s*e+o*p+a*g,s*t+o*d+a*x],[s*n+o*v+a*w,s*r+o*m+a*y],[s*i+o*h+a*j,s*f+o*b+a*k]]}}}function K(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function Q(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function X(e,t,n,r,i){return e(t,n,r,[i.projection_a,i.projection_b,i.projection_c])}function Z(){return[[[1,.3],[1,.3],[1,.3]]]}function ee(){return[[[1,.3],[1,.3],[1,.3]]]}function te(){return[[[1,.3],[1,.3],[1,.3]]]}function ne(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*re(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function ie(e,t,n){e.includes("reset")&&(t.value=n.value=[[[1,.3],[1,.3],[1,.3]]])}function*oe(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function ae(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*le(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function se(e,t){const n=e.module();n.variable(t()).define(["md"],y),n.variable(t()).define(["md"],j),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],k),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],P),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["iterate_convex","d3","iteration_pts_convex","Plot"],z),n.variable(t()).define(["md"],A),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],q),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t("two_nonconvex_sets_plot")).define("two_nonconvex_sets_plot",["iterate_nonconvex","d3","iteration_pts_nonconvex","Plot"],D),n.variable(t()).define(["md"],R),n.variable(t()).define(["tex"],M),n.variable(t()).define(["tex","md"],I),n.variable(t("viewof projection_inputs_a")).define("viewof projection_inputs_a",["Inputs"],C),n.variable(t("projection_inputs_a")).define("projection_inputs_a",["Generators","viewof projection_inputs_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_inputs_b")).define("viewof projection_inputs_b",["Inputs","projection_inputs_a","named_projection_parameters"],N),n.variable(t("projection_inputs_b")).define("projection_inputs_b",["Generators","viewof projection_inputs_b"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],$),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],S),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t("flower_sets_plot")).define("flower_sets_plot",["flower_values","iteration_pts_flower","iterate_flower","Plot"],G),n.variable(t()).define(["htl"],T);const r=e.module(w);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_inputs_a"],V),n.variable(t("flower_values")).define("flower_values",["nj"],E),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",O),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",L),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",W),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",B),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],H),n.variable(t("generalized_projection")).define("generalized_projection",F),n.variable(t("product_space_projection")).define("product_space_projection",U),n.variable(t("diagonal_projection")).define("diagonal_projection",Y),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],J),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_inputs_b"],K),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_inputs_b"],Q),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_inputs_b"],X),n.define("initial iteration_pts_convex",Z),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",ee),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",te),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["iterate_convex","mutable iteration_pts_convex"],ne),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],re),n.variable(t("two_nonconvex_sets_reset")).define("two_nonconvex_sets_reset",["iterate_nonconvex","mutable iteration_pts_nonconvex","mutable iteration_pts_convex"],ie),n.variable(t("two_nonconvex_sets_generator")).define("two_nonconvex_sets_generator",["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],oe),n.variable(t("flower_sets_reset")).define("flower_sets_reset",["iterate_flower","mutable iteration_pts_flower"],ae),n.variable(t("flower_sets_generator")).define("flower_sets_generator",["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],le),n}function ce(e){return e}function ue(e){return e}function _e(e){return e}function fe(e){return e}function pe(e){return e.html`<hr class="hideable-md" >`}function de(e){return e}function ve(e){return e}function me(e,t){const n=e.module();n.variable(t()).define(["viewof iterate_flower"],ce),n.variable(t()).define(["flower_sets_plot"],ue),n.variable(t()).define(["viewof projection_inputs_a"],_e),n.variable(t()).define(["viewof projection_inputs_b"],fe),n.variable(t()).define(["htl"],pe);const r=e.module(se);return n.import("viewof iterate_flower",r),n.import("iterate_flower",r),n.import("flower_sets_plot",r),n.import("flower_sets_generator",r),n.import("flower_sets_reset",r),n.import("viewof projection_inputs_a",r),n.import("projection_inputs_a",r),n.import("viewof projection_inputs_b",r),n.import("projection_inputs_b",r),n.variable(t()).define(["flower_sets_generator"],de),n.variable(t()).define(["flower_sets_reset"],ve),n}n.r(t),n.d(t,{default:()=>me})},7796:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),h=new e([a,l]),b=t.cos(m),g=t.sin(m);h.data=t.stack([b,g],-1);let x=u.multiply(h);return x.data=t.ifft(x.data),x}}function v(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),h=new e([a,l]),b=t.cos(m),g=t.sin(m);h.data=t.stack([b,g],-1);let x=u.multiply(h),w=new e([a,l]);return w.data=t.ifft(x.data),[x,w]}}function m(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function h(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function b(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function g(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function x(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o,a=0,l=Math.PI/2){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o,this._stig=a,this._stig_angle=l}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(l,a)]}_evaluate_aberrations(e,t){let n=Math.PI/this._wavelength,i=r.cos(t.subtract(this._stig_angle).multiply(2)).multiply(this._stig).add(this._defocus),a=e.multiply(e).multiply(i).multiply(n),l=r.cos(a),s=r.sin(a),c=new o(a.shape);return c.data=r.stack([l,s],-1),c}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i),l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this._fourier_array=a,this._aberrations=n,this._aperture=i,this}}}function w(e){return e`https://observablehq.com/@mootari/notebook-data`}function y(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("fourier_shift_extended")).define("fourier_shift_extended",["ComplexNDArray","nj","fftfreq","meshgrid2D"],v),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],m),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],h),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",b),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],g),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],x),n.variable(t()).define(["md"],w),n}function j(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function k(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function P(e){return e.range([50,1e3],{value:200,step:25,label:"Animation speed [ms]"})}function z(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function A(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function q(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function D(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function R(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function M(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function I(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function C(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function N(e){return e.form({projection_name:e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"projection"}),projection_gamma:e.range([0,1],{value:.875,step:.001,label:"relaxation \u03b3"})})}function $(e,t,n){return e.form({projection_a:e.range([-1,1],{value:`${"Generalized"==t.projection_name?0:n[t.projection_name].a}`,step:.001,label:"parameter a"}),projection_b:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].b}`,step:.001,label:"parameter b"}),projection_c:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].c}`,step:.001,label:"parameter c"})})}function S(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function G(e){return e.checkbox(["iterate","reset","individual traces"],{value:[]})}function T(e,t,n,r){let i=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),o=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length)))),a=n.includes("individual traces")?t.map((e=>e[0])):[],l=n.includes("individual traces")?t.map((e=>e[1])):[],s=n.includes("individual traces")?t.map((e=>e[2])):[];return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...i],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(a,{stroke:"red",strokeDasharray:"4 4"}),r.line(l,{stroke:"blue",strokeDasharray:"4 4"}),r.line(s,{stroke:"green",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function V(e){return e.html`<hr class="hideable-md">`}function E(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e.projection_gamma,b:e.projection_gamma,c:2},RAAR:{a:1-2*e.projection_gamma,b:e.projection_gamma,c:2}}}function O(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function L(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function W(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function B(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function H(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function F(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function U(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[[c,u],[_,f],[o*l+n*c+r*_,o*s+n*u+r*f]]}}}function Y(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function J(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function K(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[h,b]]=u([[e,t],[n,r],[i,f]]),[[g,x],[w,y],[j,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*h+c*i,l*b+c*f]]);return[[s*e+o*p+a*g,s*t+o*d+a*x],[s*n+o*v+a*w,s*r+o*m+a*y],[s*i+o*h+a*j,s*f+o*b+a*k]]}}}function Q(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function X(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function Z(e,t,n,r,i){return e(t,n,r,[i.projection_a,i.projection_b,i.projection_c])}function ee(){return[[[1,.3],[1,.3],[1,.3]]]}function te(){return[[[1,.3],[1,.3],[1,.3]]]}function ne(){return[[[1,.3],[1,.3],[1,.3]]]}function re(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*ie(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function oe(e,t,n){e.includes("reset")&&(t.value=n.value=[[[1,.3],[1,.3],[1,.3]]])}function*ae(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function le(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*se(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function ce(e,t){const n=e.module();n.variable(t()).define(["md"],j),n.variable(t()).define(["md"],k),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],P),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],z),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["iterate_convex","d3","iteration_pts_convex","Plot"],A),n.variable(t()).define(["md"],q),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],D),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t("two_nonconvex_sets_plot")).define("two_nonconvex_sets_plot",["iterate_nonconvex","d3","iteration_pts_nonconvex","Plot"],R),n.variable(t()).define(["md"],M),n.variable(t()).define(["tex"],I),n.variable(t()).define(["tex","md"],C),n.variable(t("viewof projection_inputs_a")).define("viewof projection_inputs_a",["Inputs"],N),n.variable(t("projection_inputs_a")).define("projection_inputs_a",["Generators","viewof projection_inputs_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_inputs_b")).define("viewof projection_inputs_b",["Inputs","projection_inputs_a","named_projection_parameters"],$),n.variable(t("projection_inputs_b")).define("projection_inputs_b",["Generators","viewof projection_inputs_b"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],S),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],G),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t("flower_sets_plot")).define("flower_sets_plot",["flower_values","iteration_pts_flower","iterate_flower","Plot"],T),n.variable(t()).define(["htl"],V);const r=e.module(y);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_inputs_a"],E),n.variable(t("flower_values")).define("flower_values",["nj"],O),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",L),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",W),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",B),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",H),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],F),n.variable(t("generalized_projection")).define("generalized_projection",U),n.variable(t("product_space_projection")).define("product_space_projection",Y),n.variable(t("diagonal_projection")).define("diagonal_projection",J),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],K),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_inputs_b"],Q),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_inputs_b"],X),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_inputs_b"],Z),n.define("initial iteration_pts_convex",ee),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",te),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",ne),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["iterate_convex","mutable iteration_pts_convex"],re),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],ie),n.variable(t("two_nonconvex_sets_reset")).define("two_nonconvex_sets_reset",["iterate_nonconvex","mutable iteration_pts_nonconvex","mutable iteration_pts_convex"],oe),n.variable(t("two_nonconvex_sets_generator")).define("two_nonconvex_sets_generator",["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],ae),n.variable(t("flower_sets_reset")).define("flower_sets_reset",["iterate_flower","mutable iteration_pts_flower"],le),n.variable(t("flower_sets_generator")).define("flower_sets_generator",["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],se),n}function ue(e){return e}function _e(e){return e}function fe(e){return e.html`<hr class="hideable-md">`}function pe(e){return e}function de(e){return e}function ve(e,t){const n=e.module();n.variable(t()).define(["viewof iterate_convex"],ue),n.variable(t()).define(["two_convex_sets_plot"],_e),n.variable(t()).define(["htl"],fe);const r=e.module(ce);return n.import("viewof iterate_convex",r),n.import("iterate_convex",r),n.import("two_convex_sets_plot",r),n.import("two_convex_sets_generator",r),n.import("two_convex_sets_reset",r),n.variable(t()).define(["two_convex_sets_generator"],pe),n.variable(t()).define(["two_convex_sets_reset"],de),n}n.r(t),n.d(t,{default:()=>ve})},90083:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),h=new e([a,l]),b=t.cos(m),g=t.sin(m);h.data=t.stack([b,g],-1);let x=u.multiply(h);return x.data=t.ifft(x.data),x}}function v(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),h=new e([a,l]),b=t.cos(m),g=t.sin(m);h.data=t.stack([b,g],-1);let x=u.multiply(h),w=new e([a,l]);return w.data=t.ifft(x.data),[x,w]}}function m(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function h(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function b(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function g(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function x(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o,a=0,l=Math.PI/2){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o,this._stig=a,this._stig_angle=l}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(l,a)]}_evaluate_aberrations(e,t){let n=Math.PI/this._wavelength,i=r.cos(t.subtract(this._stig_angle).multiply(2)).multiply(this._stig).add(this._defocus),a=e.multiply(e).multiply(i).multiply(n),l=r.cos(a),s=r.sin(a),c=new o(a.shape);return c.data=r.stack([l,s],-1),c}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i),l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this._fourier_array=a,this._aberrations=n,this._aperture=i,this}}}function w(e){return e`https://observablehq.com/@mootari/notebook-data`}function y(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("fourier_shift_extended")).define("fourier_shift_extended",["ComplexNDArray","nj","fftfreq","meshgrid2D"],v),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],m),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],h),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",b),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],g),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],x),n.variable(t()).define(["md"],w),n}function j(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function k(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function P(e){return e.range([50,1e3],{value:200,step:25,label:"Animation speed [ms]"})}function z(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function A(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function q(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function D(e){return e.checkbox(["iterate","reset","traces"],{value:["traces"]})}function R(e,t,n,r){let i=e.includes("traces")?t.merge(n.map((e=>[e[0],e[1]]))):[],o=n.map((e=>e[2]));return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(i,{stroke:"gray",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function M(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function I(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function C(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function N(e){return e.form({projection_name:e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"projection"}),projection_gamma:e.range([0,1],{value:.875,step:.001,label:"relaxation \u03b3"})})}function $(e,t,n){return e.form({projection_a:e.range([-1,1],{value:`${"Generalized"==t.projection_name?0:n[t.projection_name].a}`,step:.001,label:"parameter a"}),projection_b:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].b}`,step:.001,label:"parameter b"}),projection_c:e.range([0,2],{value:`${"Generalized"==t.projection_name?1:n[t.projection_name].c}`,step:.001,label:"parameter c"})})}function S(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function G(e){return e.checkbox(["iterate","reset","individual traces"],{value:[]})}function T(e,t,n,r){let i=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),o=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length)))),a=n.includes("individual traces")?t.map((e=>e[0])):[],l=n.includes("individual traces")?t.map((e=>e[1])):[],s=n.includes("individual traces")?t.map((e=>e[2])):[];return r.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[r.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...i],{x:"x",y:"y",z:"set",stroke:"col"}),r.line(o,{stroke:"orange"}),r.line(a,{stroke:"red",strokeDasharray:"4 4"}),r.line(l,{stroke:"blue",strokeDasharray:"4 4"}),r.line(s,{stroke:"green",strokeDasharray:"4 4"}),r.dot(o,{fill:"orange",fillOpacity:.5,r:10})]})}function V(e){return e.html`<hr class="hideable-md">`}function E(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e.projection_gamma,b:e.projection_gamma,c:2},RAAR:{a:1-2*e.projection_gamma,b:e.projection_gamma,c:2}}}function O(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function L(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function W(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function B(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function H(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function F(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function U(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[[c,u],[_,f],[o*l+n*c+r*_,o*s+n*u+r*f]]}}}function Y(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function J(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function K(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[h,b]]=u([[e,t],[n,r],[i,f]]),[[g,x],[w,y],[j,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*h+c*i,l*b+c*f]]);return[[s*e+o*p+a*g,s*t+o*d+a*x],[s*n+o*v+a*w,s*r+o*m+a*y],[s*i+o*h+a*j,s*f+o*b+a*k]]}}}function Q(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function X(e,t,n,r){return e(t,n,[r.projection_a,r.projection_b,r.projection_c])}function Z(e,t,n,r,i){return e(t,n,r,[i.projection_a,i.projection_b,i.projection_c])}function ee(){return[[[1,.3],[1,.3],[1,.3]]]}function te(){return[[[1,.3],[1,.3],[1,.3]]]}function ne(){return[[[1,.3],[1,.3],[1,.3]]]}function re(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*ie(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function oe(e,t,n){e.includes("reset")&&(t.value=n.value=[[[1,.3],[1,.3],[1,.3]]])}function*ae(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1][2])]}}function le(e,t){e.includes("reset")&&(t.value=[[[1,.3],[1,.3],[1,.3]]])}function*se(e,t,n,r,i,o){let a=0;for(;e.includes("iterate");){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function ce(e,t){const n=e.module();n.variable(t()).define(["md"],j),n.variable(t()).define(["md"],k),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],P),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],z),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["iterate_convex","d3","iteration_pts_convex","Plot"],A),n.variable(t()).define(["md"],q),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],D),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t("two_nonconvex_sets_plot")).define("two_nonconvex_sets_plot",["iterate_nonconvex","d3","iteration_pts_nonconvex","Plot"],R),n.variable(t()).define(["md"],M),n.variable(t()).define(["tex"],I),n.variable(t()).define(["tex","md"],C),n.variable(t("viewof projection_inputs_a")).define("viewof projection_inputs_a",["Inputs"],N),n.variable(t("projection_inputs_a")).define("projection_inputs_a",["Generators","viewof projection_inputs_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_inputs_b")).define("viewof projection_inputs_b",["Inputs","projection_inputs_a","named_projection_parameters"],$),n.variable(t("projection_inputs_b")).define("projection_inputs_b",["Generators","viewof projection_inputs_b"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],S),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],G),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t("flower_sets_plot")).define("flower_sets_plot",["flower_values","iteration_pts_flower","iterate_flower","Plot"],T),n.variable(t()).define(["htl"],V);const r=e.module(y);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_inputs_a"],E),n.variable(t("flower_values")).define("flower_values",["nj"],O),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",L),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",W),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",B),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",H),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],F),n.variable(t("generalized_projection")).define("generalized_projection",U),n.variable(t("product_space_projection")).define("product_space_projection",Y),n.variable(t("diagonal_projection")).define("diagonal_projection",J),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],K),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_inputs_b"],Q),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_inputs_b"],X),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_inputs_b"],Z),n.define("initial iteration_pts_convex",ee),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",te),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",ne),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["iterate_convex","mutable iteration_pts_convex"],re),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],ie),n.variable(t("two_nonconvex_sets_reset")).define("two_nonconvex_sets_reset",["iterate_nonconvex","mutable iteration_pts_nonconvex","mutable iteration_pts_convex"],oe),n.variable(t("two_nonconvex_sets_generator")).define("two_nonconvex_sets_generator",["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],ae),n.variable(t("flower_sets_reset")).define("flower_sets_reset",["iterate_flower","mutable iteration_pts_flower"],le),n.variable(t("flower_sets_generator")).define("flower_sets_generator",["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],se),n}function ue(e){return e}function _e(e){return e}function fe(e){return e}function pe(e){return e}function de(e){return e.html`<hr class="hideable-md" >`}function ve(e){return e}function me(e){return e}function he(e,t){const n=e.module();n.variable(t()).define(["viewof iterate_nonconvex"],ue),n.variable(t()).define(["two_nonconvex_sets_plot"],_e),n.variable(t()).define(["viewof projection_inputs_a"],fe),n.variable(t()).define(["viewof projection_inputs_b"],pe),n.variable(t()).define(["htl"],de);const r=e.module(ce);return n.import("viewof iterate_nonconvex",r),n.import("iterate_nonconvex",r),n.import("two_nonconvex_sets_plot",r),n.import("two_nonconvex_sets_generator",r),n.import("two_nonconvex_sets_reset",r),n.import("viewof projection_inputs_a",r),n.import("projection_inputs_a",r),n.import("viewof projection_inputs_b",r),n.import("projection_inputs_b",r),n.variable(t()).define(["two_nonconvex_sets_generator"],ve),n.variable(t()).define(["two_nonconvex_sets_reset"],me),n}n.r(t),n.d(t,{default:()=>he})}}]);